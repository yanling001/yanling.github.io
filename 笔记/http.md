## HTTP 
#### HTTP协议的特点：
* 用于客户端与服务端的通信协议
* 通过请求和响应的交换达成通信
* HTTP  请求是无状态的（cookie，token）
* 以URI来定位资源 
* 持久连接与管线化（新版本的HTTP协议）
###### HTTP/1.1的新特性
1. 默认是长连接
2. 支持流水线
3. 支持同时打开多个 TCP 连接
4. 支持虚拟主机
5. 新增状态码 100
6. 支持分块传输编码
7. 新增缓存处理指令 max-age
#### HTTP的组成 
######  请求报文段:
* 报文首部
1. 请求行 ：GET /index.jsp m HTTP/1.1 
2. 请求首部字段
* 接受的数据形式(accpet)，接受的字符集(accept-charset)，编码(accept-encoding)，优先的语言(accpet-language)
* web认证信息(Authorization),代理服务器要求的认证信息(Proxy-Authorization)
* 请求所在的资源服务器（HOST）
* 请求数据的范围(range)
* HTTP客户端的程序信息（User-Agent）
* Cookie
3. 通用首部字段
* 缓存控制(Cache-Control)
* 连接控制(Connection)
* 日期（Date）
* 报文主体的编码格式(Transfer-encoding)
* 升级为其他协议 (upgrade)
* 错误通知(warning)
4. 实体首部字段
* 实体语言(content-language)，实体的编码(content-encoding)，实体的位置范围(content-range)，实体的媒体类型(content-type)
* 支持的HTTP方法(allow)
* 主体过期时间(expires)，资源的最后修改日期(last-modified)
###### 报文主体
######  响应报文段
* 报文首部
1. 状态行： HTTP/1.1 20 OK
2. 响应首部字段
* 是否接受Range范围的请求(Accept-Ranges)
* 客户端重定向指定的URI(Location)
* 推算资源的创建时间(Age)
* 资源匹配信息(ETag)
* 代理服务器的对客户端的认证信息(Proxy-Authenticate)，服务器对客户端的认证信息(www-Authenicate)
* Set-Cookie
3. 通用首部字段
4. 实体首部字段

######  报文主体

#### HTTP的响应状态码
###### 成功的 2xx
* 200 : 请求成功(Ok)
* 204 ：请求成功但是没有资源返回(No Content)
* 206 ： 特指客户端的范围请求,响应包含Content-Range字段(Partial-Content)
###### 重定向的 3XX
* 301 ：永久性重定向(Moved Permanently)响应Location字段返回重定向的URL
* 302 ：临时重定向(Found)：表示请求资源分配到新的URI
* 303 ：See Other
* 304 ：Not Modified（资源找到，但未符合条件请求）
* 307 ：临时重定向
###### 客户端错误的 4XX
* 400 ：服务器无法理解请求内容(Bad Request) 请求报文中可能存在语法错误 
* 401 ：Unauthorized 未认证
* 403 ：Forbidden 禁止访问此资源
* 404 ：Not found 服务器没有请求的资源
###### 服务器错误的 5XX
* 500 ： 服务器内部出错
* 503 ：服务器繁忙
#### HTTPS
* HTTP+ssl
* CA证书：(服务端提交pk给CA，CA拿自己的CSK加密生成证书)
1. CA证书的内容:包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。
###### 验证证书安全性过程
1. 当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。
2. 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。

###### HTTPS具体交互流程：
1. client向server发送请求https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。
2. server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。
3. 随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。
4. 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。
5. 客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。
6. 传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。
7. 服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。
8. 客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。
9. 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。


#### HTTP/2.0与HTTP/1.X
###### HTTP/1.X的问题：
1. HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
2. 单向请求，只能由客户端发起。
3. 请求报文与响应报文首部信息冗余量大。
4. 数据未压缩，导致数据的传输量大
######  SPDY（瓶颈解决）
* SPDY：Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。==目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。==
######  [SPDY的具体实现](https://segmentfault.com/a/1190000016656529?utm_source=tag-newest)：
* 二进制传输 ：在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。
* 多路复用 ： HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。
帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。
* Header压缩
* 服务器Push
* 更安全
#### [HTTP的扩展WebSoket](https://www.yuque.com/aqfz37/ynepiy/ip9wkp)


