## JVM的内存区域
#### 运行时的数据区域
##### 程序计数器
* 作用 : 当前线程执行字节码的行号指示器，通过计数器的值来确定下一条需要执行的字节码指令(分支循环，跳转异常处理，线程恢复都需要计数器完成)
* 特点：
1. 线程私有
2. 当程序执行java方法时计数器记录正在执行的指令地址，当执行native方法时计数器为空
3. 内存区域中唯一一个不会出现内存溢出的区域
##### java虚拟机栈
* 每个方法执行的同时会创建栈帧，每一个方法的调用和执行完成都会对应一次栈帧的入栈与出栈。
* 特点：线程私有
######  栈帧的内容：
* 局部变量表
1. 存放着编译期可知的数据类型(boolean,byte,char,short....)基本数据类型
2. 对象引用(reference)
3. 指向下一条指令码的地址(returnAddress)
* 操作数栈

```
public static void main(String[] args) {
int i=1;
i=i++;
int j=i++;
System.out.println("i="+i);
System.out.println("j="+j);
}
输出
i=2
j=1

int i=1; 在局部变量表中分配变量int i ,将1放入操作数栈  然后将操作数栈的值赋给局部变量表。
i = i++; 因为i++（++在后）所以先将i压入操作数栈，然后在自增（自增的是局部变量表的值）
此时的操作数栈和局部变量表中i的值是：1(操作数栈)   2(局部变量表)
最后在将操作数栈的值赋给局部变量表所以此时的局部变量表的值是1;
int j=i++;  将1的值压入操作数栈，在局部变量表中分配int  j将操作数栈的值压入局部变量表j=1;
然后在将局部变量表i的值自增为2.所以输出
i=2
j=1
```

* 动态链接 :在运行时将符号引用转换成直接引用
* 方法出口
##### 本地方法栈
* native方法压入的栈。
##### 方法区(永久代)
* 作用 : 用于存储已被虚拟机加载的类信息,常量,静态变量(可以理解为编译器编译后的代码数据)
##### 运行时常量池
* 类文件的常量池部分(字面量和符号引用)在运行时加载进方法区就存放在运行时常量池
##### 字符串常量池
##### Java堆：在垃圾回收时再看

## 对象创建与回收
#### 对象创建
* 创建对象的方式：new ,clone,反序列化
* 创建对象的流程：
1. 判断类是不是被加载(在常量池能不能定位到类的符号引用)
2. 为对象分配内存(指针碰撞(Serial和ParNew的带Compact的收集器))，空闲列表(CMS基于Mark-Sweep算法的收集器))
3. 分配完成后虚拟机需要将分配到的内存空间都初始化为0(不包括对象头)
4. 对对象进行必要的设置(对象是哪个类的实例，Hashcode...这些数据存在对象头之中)
#### 对象的内存布局
* 对象头
1. Mark Word (Hashcode,gc年龄,锁状态标志,线程持有锁,偏向线程id)
2. 类型指针(指向类源信息的指针)
* 实例数据
* 对齐填充
#### 对象内存回收
###### 如何判断对象已死
1. 引用计数法
2. 可达性分析算法:找到与GCROOT根的引用链
3. 那些可以做GCroot(虚拟机栈引用的对象,方法区中的类静态属性引用的对象,方法区中常量引用的对象,本地方法栈引用的对象)
###### 如何收集垃圾
* 标记-清除算法(Mark-Sweep)
1. 问题：时间效率低，造成内存碎片
2. 适用：老年代
3. 实例:
* 复制算法 
1. 问题: 内存开销变大，用于对象存活率高的内存区域效率低
2. 好处 : 解决了内存碎片问题
3. 适用 : 年轻代
* 标记整理(Mark-Compact)
1. 适用于老年代
2. 问题：时间成本高
3. 好处 :没内存碎片
* 堆的分区与分代收集
1.  Eden
2. survivor（from区和to区两部分复制的实现区域）
3. 老年代
4.  分区间转化步骤：将from的未标记的对象复制到to区（因为此时to区为空所以可以使用to区连续的空间)。之后清除from区此时to变为from区from变为to区。
### 垃圾回收器
1. Serial收集器(新生代收集器)
* 单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。
* 应用场景：适用于Client模式下的虚拟机。
2. ParNew收集器(新生代收集器)
* 除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）
* 应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。
3. Parallel收集器(新生代收集器)
* 特点： 吞吐量优先收集器
* 属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。
该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）
4. Serial Old 收集器(老年收集器)
* 同样是单线程收集器，采用标记-整理算法。
* 应用场景：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。
Server模式下主要的两大用途（在后续中详细讲解···）：
5. Parallel Old 收集器
* 多线程，采用标记-整理算法。
* 场景： 注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。
6. CMS收集器(老年收集器)
* 特点：基于标记-清除算法实现。并发收集、低停顿。
* 应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务。
######  CMS的执行流程：
* 初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。
* 并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。
* 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。
* 并发清除：对标记的对象进行清除回收。
 CMS收集器的内存回收过程是与用户线程一起并发执行的。 

7. G1收集器(整堆收集器)
* Region
* Remembered Set
## [类加载](https://blog.csdn.net/qq330983778/article/details/99687141?utm_source=app)
###### 1. 加载
* 将字节码文件加载到方法区
###### 2. 验证 （验证，准备，解析都属于连接）
* 验证类是不是满足jvm指令规范。
###### 3. 准备
* 为静态分配空间设置默认值
1. 如果static修饰的基本变量是final修饰的那么在准备阶段就会赋值
2. 如果static修饰的基本变量不是final的话赋值在初始化阶段完成
3. 如果static和final修饰的是引用类型赋值也是在初始化的时候完成

###### 4. 解析
* 将常量池中的符号引用转换成直接引用
###### 5.初始化(通过执行类的构造方法的过程)
* 特点： 类初始化是懒惰的。
* 发生时机：
1. main方法所在的类首先会初始化
2. 首次访问这个类得静态变量和静态方法的时候
3. 子类初始化但是父类还没有初始化的时候
4. 子类访问父类得静态变量得时候
5. new
6. Class.forname()的时候
* 何时不会触发
1. 访问类的static final 修饰的变量的时候
2. 对象.class的时候不会
3. 创建类数组的时候不会
#### 类加载器
* 类加载器的分类
1. 启动类加载器(bootstrap java自己原有的类: String , Object..)
2. 扩展类加载器(Extension : java中的javax 开头的jar包：指Java的后续为发展需要提供的jar包。)
3. 应用类加载器(自己定义的类类加载器是Appliccation。)
4. 自定义类加载器
###### 双亲委委派机制
 * **委派机制**  ：当一个类加载和初始化的时候，类仅在有需要加载的时候被加载。假设你有一个应用需要的类叫作Abc.class，首先加载这个类的请求由Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器。Bootstrap类加载器会先看看rt.jar中有没有这个类，因为并没有这个类，所以这个请求由回到Extension类加载器，它会查看jre/lib/ext目录下有没有这个类，如果这个类被Extension类加载器找到了，那么它将被加载，而Application类加载器不会加载这个类；而如果这个类没有被Extension类加载器找到，那么再由Application类加载器从classpath中寻找。记住classpath定义的是类文件的加载目录，而PATH是定义的是可执行程序如javac，java等的执行路径。
**（防止用户的类污染java 的自带类：String , Object.....）**
