### 进程与线程的基本概念
###### 1. 调度方面：
* 进程是系统分配资源的最小单位
* 线程是cpu调度的最小单位
###### 2. 资源 ：
* 进程 ：操作系统会为进程有独立的内存地址还会为其建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
* 线程使用隶属进程的内存地址即一个进程中可以有多个线程，它们共享进程资源（具体线程间堆内存共享，栈内存私有操作系统在切换线程的时候会自动的切换栈，就是切换ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放）
###### 3. 通信 ：
* 进程：只能通过 IPC
* 线程：可以共享全局和静态的变量
* IPC 的方式：
1. 共享内存
2. 管道
3. FIFO
4. 信号量（这里指的是：它是一个计数器，用于为多个进程提供对共享数据对象的访问。） 
5. 消息队列
6. 套接字
###### 系统开销
* 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
### 进程的同步
* 同步 ：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
* 互斥： 多个进程在同一时刻只有一个进程能进入临界区。
* 临界区： 公共资源的代码同一时刻只能有一个进程访问 即对临界资源进行访问的那段代码称为临界区。
##### 实现同步的方法
* 信号量 小于等于0是等待大于零时唤醒
* 互斥量
* 管程 特点：同一时刻只能有一个线程操作管程，管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。
 ### 进程状态
* 就绪态
* 执行态
* 阻塞态
*  转换：
1. 就绪-->运行(进程调度)
2. 运行-->就绪(时间片用完)
3. 运行-->阻塞(io请求...特殊资源调度)
4. 阻塞-->就绪(io完成)
### 进程调度
###### 批处理系统
* 先来先服务
* 最短作业优先
* 剩余时间最短
###### 交互系统
* 时间片轮转
* 优先级调度
* 多级反馈队列
## 死锁
###### 形成条件
* 互斥（一个资源不能也同时分配给两个进程）
* 占有等待（一个进程因请求资源而阻塞时对以获得资源不放）
* 不可抢占 （分给给别的进程的资源不能强行抢占）
* 环路等待
###### 避免方法
* 死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。
1. 死锁检测：每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
2. 死锁恢复：利用抢占恢复 利用回滚恢复 通过杀死进程恢复

* 死锁预防：在程序运行之前预防发生死锁。  即：破坏四大形成条件
* 死锁避免：在程序运行时避免发生死锁。 即 ：银行家算法