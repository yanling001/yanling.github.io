## TCP的报文段
###### 源端口 目的端口
* 作用确定数据的发送方和接收方
######  序号
* 从0开始到2的31次幂，将数据每一个字节对应一个序号在tcp建立时双方要各自确定初始号(一般初始号随机为了安全)
* 作用：将数据分序号，累计确认(对所有顺序接收到的数据的确认)实现可靠传输
######  确认号
* 表示期望收到的下一个报文段的第一个数据字节的序号
* 扩展功能：快重传(连收到3个ACK就会重发数据不会等到超时在重传)
######  数据偏移与保留
* 数据偏移放映的时TCP的报文段首部字段的长度

###### 六个标志位
* 紧急URG : 当URG等于1的时候紧急指针有效tcp有紧急数据交付给应用 
* 确认ACK 只有当ACK=1时确认号字段才有效(建立/断开连接时用到)
* 推送PUSH
* 复位 RST
* 同步 SYN(三次握手中用到)
* 终止 FIN(断开连接)
######  窗口
* 滑动窗口协议流量控制，拥塞控制
######  检验和紧急指针
* 校验 ：确保数据准确
* 与URG一起使用
## TCP的连接建立与有限状态机
###### 三次握手建立连接
1. client向server放送 ：ACK=0,SYN=1,sep=x;(seq:序号字段带个随机数) 客户端进入SYN_SEND同步已发送状态。
2. server向client发送 : ACK=1,SYN=1,seq=y,ack=x+1;服务器进入SYN_RCVD同步收到状态
3. client向sever发送 : SYN=0,ACK=1,seq=x+1,ack=y+1;(同时进入ESTABLISHED)
######  常问问题
1. 为什么要三次握手四次两次可以不 ?
2. Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？
3. TCP的初始序列号为什么要随机 ?
4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
* TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
5. [全连接队列,半连接队列,backlog，accept](https://zhuanlan.zhihu.com/p/39048792)
6. Linux内核的两条Socket队列(ESTABLISHED，SYN_RCVD)
7. TCP的有限状态机
8. 建立连接需要三次握手，也不一定都是三次，有可能出现四次握手来建立连接的
9. 初始化序列号X、Y是可以是写死固定的吗，为什么不能呢？
10. 假如Client发送一个SYN包给Server后就挂了或是不管了，这个时候这个连接处于什么状态呢？会超时吗？为什么呢？
11. RST包为什么叫RST， [RST包的作用](https://blog.csdn.net/a_tu_/article/details/80389878)
12. TCP在listen时候参数backlog的意义？
* SYN队列的长度
13. 三次握手有哪些不安全性？
* SYN flood 泛洪攻击 
* Land 攻击 
###### 四次挥手结束连接
1.  client向server发送 : FIN=1,seq=u; (其中u是client已经发送的数据最后一个字节数加1,此时client进入了FIN-WAIT-1)
2.  server向client发送 : ACK=1,seq=v,ack=u+1;(v:是server已经发送的数据最后一个字节数加1,此时server进入Close-wait)
* close-wait: 半关闭状态：server还可以给client发送数据
3.  server向client发送 : FIN=1,ACK=1,seq=v,ack=u+1;(此时server进入Last-cak)
4.  client向server发送 : ACK=1,seq=u+1,ack=v+1;(此时client端进入time-wait)
###### 常问问题
1. 为什么得4次挥手，3次行不行
2. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
3.  Client和Server同时发起断开连接的FIN包会怎么样呢，TCP状态是怎么转移的?
4.  左侧图中的四次挥手过程中，Server端的ACK确认包能不能和接下来的FIN包合并成一个包呢，这样四次挥手就变成三次挥手了。
5.  四次挥手过程中，首先断开连接的一端，在回复最后一个ACK后，为什么要进行TIME_WAIT呢(超时设置是 2*MSL，RFC793定义了MSL为2分钟，Linux设置成了30s)，在TIME_WAIT的时候又不能释放资源，白白让资源占用那么长时间，能不能省了TIME_WAIT呢，为什么(TIME-WAIT的意义)？
6.  TIME_WAIT会带来哪些问题呢？
7.  TIME_WAIT的快速回收和重用
8.  有那两种方式可以控制服务器的TIME_WAIT数量
###### TCP的可靠传输
1. 数据编号与累积确认
2. 超时重传与快重传
* RTT的计算
* 快重传触发的条件
3. 基于滑动窗口协议的流量控制
* rwnd(recevier window)与接受缓存的关系
* 发送方如何确定窗口的大小
* 发送滑动窗口的上限=min(rwnd,cwnd);
4. 拥塞控制
*  慢开始算法
* 拥塞避免
* 快速恢复
###### 常见问题
1. TCP的可靠传输是确认号来实现的，那么TCP的确认机制是怎样的呢？是收到一个包就马上确认，还是可以稍等一下在确认呢？
2. ）假如发送一个包，一直都没收到确认呢？什么时候重传呢？超时机制的怎样的？
3. TCP两端Peer的处理能力不对等的时候，比如发送方处理能力很强，接收方处理能力很弱，这样发送方是否能够不管接收方死活狂发数据呢？如果不能，流量控制机制的如何的？
4. TCP是端到端的协议，也就是TCP对端Peer只看到对方，看不到网络上的其他点，那么TCP的两端怎么对网络情况做出反映呢？发生拥塞的时候，拥塞控制机制是如何的？
5. 关于重传计时器 ：采取每一个TCP连接单一超时定时器的设计则成了一个默认的选择，并且RFC2988给出了每连接单一定时器的设计建议算法规则(详见TCP文档)
6. tcp的计时器
7. tcp的SACK 和D-SACK
8. 滑动窗口的零窗口问题



