### [Zookeeper](https://www.jianshu.com/p/39736c054e88)
* 什么是Zookeeper?
1. ZooKeeper 本质上是一个分布式的小文件存储系统。提供基于类似于文件系
统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维
护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达
到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队
列、分布式锁、分布式协调等功能。
* ZooKeeper 特性
1. **全局数据一致**：集群中每个服务器保存一份相同的数据副本，client 无
论连接到哪个服务器，展示的数据都是一致的，这是最重要的特征；
2. **可靠性**：如果消息被其中一台服务器接受，那么将被所有的服务器接受。
3. **顺序性**：包括全局有序和偏序两种：全局有序是指如果在一台服务器上
消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被
发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必
将排在 b 前面。
4. **数据更新原子性**：一次数据更新要么成功（半数以上节点成功），要么失
败，不存在中间状态；
5. **实时性**：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的
更新信息，或者服务器失效的信息。
北京市昌平区建材城西路金燕龙办公楼一层
#### ZooKeeper 集群
![image](https://upload-images.jianshu.io/upload_images/17533594-be7f21c03cc1d9f2.jpg)
* **Leader**
* Zookeeper 集群工作的核心
事务请求（写操作）的唯一调度和处理者，保证集群事务处理的顺序性；
集群内部各个服务器的调度者。
对于 create，setData，delete 等有写操作的请求，则需要统一转发给
leader 处理，leader 需要决定编号、执行操作，这个过程称为一个事务。
* **Follower**
* 处理客户端非事务（读操作）请求，转发事务请求给 Leader；
参与集群 Leader 选举投票。
此外，针对访问量比较大的 zookeeper 集群，还可新增观察者角色。
* **Observer**
* 观察者角色，观察 Zookeeper 集群的最新状态变化并将这些状态同步过
来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给 Leader
服务器进行处理。
不会参与任何形式的投票只提供非事务服务，通常用于在不影响集群事务
处理能力的前提下提升集群的非事务处理能力。
##### ZK的数据模型
* ZooKeeper命名空间中的Znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子znode。用户对znode具有增、删、改、查等操作（权限允许的情况下）。
* **Znode特点**
1. znode具有原子性操作，每个znode的数据将被原子性地读写，读操作会读取与znode相关的所有数据，写操作会一次性替换所有数据。zookeeper并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。zooKeeper的服务器和客户端都被设计为严格检查并限制每个znode的数据大小至多1M，当时常规使用中应该远小于此值。
![image](https://upload-images.jianshu.io/upload_images/6570150-cc9144d461019982)
* 图中的每个节点称为一个znode. 每个znode由3部分组成
1. stat：此为状态信息, 描述该znode的版本, 权限等信息.
2. data：与该znode关联的数据.
3. children：该znode下的子节点.

#### Znode的特征
###### Watches 发布订阅
客户端可以在节点上设置watch(我们称之为监视器)。当节点状态发生改变时(数据的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。
###### 数据访问
ZooKeeper中的每个节点存储的数据要被原子性的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。
###### 节点类型
* ZooKeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即被确定，并且不能改变。

1.　ZooKeeper的临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。另外，需要注意是，ZooKeeper的临时节点不允许拥有子节点。

2.　　ZooKeeper的永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。
###### 顺序节点（唯一性的保证）
* 当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个递增的计数。这个计数对于此节点的父节点来说是唯一的，它的格式为“%10d”(10位数字，没有数值的数位用0补充，例如“0000000001”)。当计数值大于232-1时，计数器将溢出。
org.apache.zookeeper.，分别对应：
1. PERSISTENT：永久节点
2. EPHEMERAL：临时节点
3. PERSISTENT_SEQUENTIAL：永久节点、序列化
4. EPHEMERAL_SEQUENTIAL：临时节点、序列化


#### ZooKeeper 选举机制
######  基本概念
1. 服务器 ID
* 比如有三台服务器，编号分别是 1,2,3。
编号越大在选择算法中的权重越大。
2. 选举状态
* LOOKING，竞选状态。
* FOLLOWING，随从状态，同步 leader 状态，参与投票。
* OBSERVING，观察状态,同步 leader 状态，不参与投票。
* LEADING，领导者状态。
3. 数据 ID
* 服务器中存放的最新数据 version。
值越大说明数据越新，在选举算法中数据越新权重越大。
4. 逻辑时钟
* 也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票
这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，
根据不同的值做出不同的判断。

##### 全新集群选举
* 假设目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是
1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
1. 服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。 
2.  服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由
于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，
所以两个服务器的状态依然是 LOOKING。 
3. 服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，
由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，
所以服务器 3 成为领导者，服务器 1,2 成为小弟。
4. 服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，
尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能
成为小弟。
5. 服务器 5 启动，后面的逻辑同服务器 4 成为小弟。

###### 非全新集群选举
* 对于运行正常的 zookeeper 集群，中途有机器 down 掉，需要重新选举时，
* 选举过程就需要加入数据 ID、服务器 ID 和逻辑时钟。
* 数据 ID：数据新的 version 就大，数据每次更新都会更新 version。
* 服务器 ID：就是我们配置的 myid 中的值，每个机器一个。
* 逻辑时钟：这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举
中,这个值是一致的。

**这样选举的标准就变成：**

1. 逻辑时钟小的选举结果被忽略，重新投票； 
2.  统一逻辑时钟后，数据 id 大的胜出； 
3.  数据 id 相同的情况下，服务器 id 大的胜出；
根据这个规则选出 leader。